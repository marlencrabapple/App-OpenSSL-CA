#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/OpenSSL/CA.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_OPENSSL_CA';
  use Object::Pad qw(:experimental(:all));
  
  package App::OpenSSL::CA;
  
  class App::OpenSSL::CA : does(App::OpenSSL::CA::Base);
  
  our $VERSION = 0.01;
  
  use utf8;
  use v5.40;
  
  use Getopt::Long 'GetOptionsFromArray';
  use Data::Dumper;
  use Encode qw(encode decode);
  use Const::Fast;
  use List::Util qw'first any';
  use Path::Tiny;
  use IPC::Run3;
  
  use App::OpenSSL::CA::Base;
  
  Getopt::Long::Configure("auto_abbrev");
  Getopt::Long::Configure("pass_through");
  Getopt::Long::Configure("long_prefix_pattern=-");
  
  const our @OPENSSL_CMDS => qw(req ca pkcs12 x509 verify);
  
  const our $OPENSSL        => $ENV{'OPENSSL'} //= "openssl";
  const our @OPENSSL        => split /[\s\n\r]+/, $OPENSSL;
  const our $OPENSSL_CONFIG => $ENV{"OPENSSL_CONFIG"} // "";
  const our @OPENSSL_CONFIG => $OPENSSL_CONFIG =~ /^[\s\r\n]*
          ([^=\:\s])
          [^=\:\s]1
          ([^=\:\s])
      [\s\r\n]*$/x;
  
  # Command invocations.
  const our @REQ    => ( @OPENSSL, "req", @OPENSSL_CONFIG );
  const our @CA     => ( @OPENSSL, "ca",  @OPENSSL_CONFIG );
  const our @VERIFY => ( @OPENSSL, "verify" );
  const our @X509   => ( @OPENSSL, "x509" );
  const our @PKCS12 => ( @OPENSSL, "pkcs12" );
  
  # Default values for various configuration settings.
  const our $CATOP      => $ENV{CATOP}  // "/etc/ssl";
  const our $CAKEY      => $ENV{CAKEY}  // "cakey.pem";
  const our $CAREQ      => $ENV{CAREQ}  // "careq.pem";
  const our $CACERT     => $ENV{CACERT} // "cacert.pem";
  const our $CACRL      => $ENV{CACRL}  // "crl.pem";
  const our @DAYS       => ( '-days',       $ENV{DAYS}   // 365 );
  const our @CADAYS     => ( '-days',       $ENV{CADAYS} // 365 * 3 );   # 3 years
  const our @EXTENSIONS => ( '-extensions', $ENV{EXTENSIONS} // 'ca_ext' );
  const our @POLICY     => ( '-policy',     $ENV{POLICY} // 'policy_anything' );
  const our $NEWKEY     => $ENV{NEWKEY}  // "newkey.pem";
  const our $NEWREQ     => $ENV{NEWREQ}  // "newreq.pem";
  const our $NEWCERT    => $ENV{NEWCERT} // "newcert.pem";
  const our $NEWP12     => $ENV{NEWP12}  // "newcert.p12";
  
  # Set CLI defaults from run environment
  field $cliopts : param(dest) {
  
      my %cliopts = (
          map {
              my $name = $_;
              my $val =
                first { $_ } @ENV{ map { uc "$_$name" } ( 'ca_', '' ) };
              $name => $val
          } qw(verbose debug)
      );
  
      dmsg { ENV => \%ENV, cliopts => \%cliopts };
  
      \%cliopts
  };
  
  field $argv : param;
  field $verbose = $ENV{verbose} // 1;
  field $extra : mutator;
  field $what  : mutator;
  
  field $ret : reader = 0;    # TODO: either
                              #  - alias this to $? in err or
                              #  - exit $ret in DESTROY?
  
  field $method : mutator;
  
  field $san;
  
  const our $OPTION_RE_STR => join '|', map {quotemeta $_ }
    qw(newcert newreq newreq-nodes xsign
    sign signCA signcert crl
    newca pkcs12 verify revoke help h ? verbose);
  
  const our $OPTION_RE => qr/^-($OPTION_RE_STR)$/;
  
  ADJUSTPARAMS($params) {
      foreach (@OPENSSL_CMDS) {
          $$extra{$_} = [];
      }
  
      GetOptionsFromArray(
          $argv, $cliopts,
  
          # 'newcert' 'newreq' 'newreq-nodes' 'xsign'
          #   'sign' 'signCA' 'signcert' 'crl'
          #   'newca' 'pkcs12' 'verify' 'revoke'
  
          'subject=s%',
          'san|ubject-alt-name=s%',
          'help|?',
  
          'verbose',
  
          ( map { "extra-$_=s%" } @OPENSSL_CMDS ),
  
          '<>' => sub ($cmd) {
              my ($method) = ( $cmd =~ $OPTION_RE );
              $method = 'help' if $$cliopts{help};
  
              dmsg {
                  cmd              => $cmd,
                  method           => $method,
                  '$OPTION_RE_STR' => $OPTION_RE_STR,
                  '$OPTION_RE'     => $OPTION_RE
              };
  
              __PACKAGE__->help("'$cmd' is not a valid option:")
                unless $method;
  
              $self->method = $method;
  
              dmsg {
                  cliopts => $cliopts,
                  argv    => $argv,
                  what    => $what,
                  method  => $method
              };
          }
      );
  }
  
  method do : common ( $argv, %constructor ) {
      my $ca = $class->new( argv => $argv, %constructor );
  
      dmsg {ca => $ca};
  
      my $method = $ca->method;
      $ca->$method;
      $ca->ret;
  }
  
  method touch ( $file, %opts ) {
      $opts{iolayer} //= '';
      $opts{close}   //= 1;
  
      open my $fh, ">$opts{iolayer}", $file;
      close $fh if $opts{close};
      path($file);
  }
  
  # See if reason for a CRL entry is valid; exit if not.
  method crl_reason_ok ($r) {
      if (   $r eq 'unspecified'
          || $r eq 'keyCompromise'
          || $r eq 'CACompromise'
          || $r eq 'affiliationChanged'
          || $r eq 'superseded'
          || $r eq 'cessationOfOperation'
          || $r eq 'certificateHold'
          || $r eq 'removeFromCRL' )
      {
          return 1;
      }
      warn "Invalid CRL reason; must be one of:\n";
      warn "    unspecified, keyCompromise, CACompromise,\n";
      warn "    affiliationChanged, superseded, cessationOfOperation\n";
      warn "    certificateHold, removeFromCRL";
  
      1;
  }
  
  method copy_pemfile ( $infile, $outfile, $bound, %opts ) {
      my $found = 0;
  
      $opts{iolayer} //= "";
  
      open( my $IN, '<' . $opts{iolayer}, $infile )
        || err "Cannot open '$infile' for reading: $!", $?;
      open( my $OUT, '>', "$outfile" )
        || err "Cannot write to '$outfile': $!", $?;
  
      while ( my $line = <$IN> ) {
          $found = 1       if $line =~ /^-----BEGIN.*$bound/;
          print $OUT $line if $found;
          $found = 2, last if $line = !/^-----END.*$bound/;
      }
  
      close $IN;
      close $OUT;
  
      $found == 2 ? 0 : 1;
  }
  
  method run ( $cmd, %opts ) {
      $App::OpenSSL::CA::run::read_stdin //= 1;
      my $read_stdin = $opts{stdin} // $App::OpenSSL::CA::run::read_stdin // 1;
  
      my $bin = shift @$cmd;
      say "====\n$bin " . join ' ', @$cmd if $verbose;
  
      my $run3ret = run3(
          [ $bin, @$cmd ],
          (
                $read_stdin == 1 ? undef
              : $read_stdin == 0 ? \undef
              :                    undef
          ),
  
          $opts{outh} // undef,
          $opts{errh} // undef
      );
  
      my $status = $? // 0;
      say "==> $status\n====" if $verbose;
  
      $status >> 8;
  }
  
  method newcert {
      $self->run(
          [
              @REQ,    qw(-new -x509 -keyout),
              $NEWKEY, "-out", $NEWCERT, @DAYS, $$extra{req}->@*
          ]
      );
  }
  
  method precert {
  
      # create a pre-certificate
      $ret = $self->run(
          [
              @REQ,    qw(-x509 -precert -keyout),
              $NEWKEY, "-out", $NEWCERT, @DAYS, $$extra{req}->@*
          ]
      );
  
      say "Pre-cert is in $NEWCERT, private key is in $NEWKEY" if $ret == 0;
  }
  
  method newreq {
      my ($nodes) = ( $what =~ /^\-newreq(\-nodes)?$/ );
  
      # create a certificate request
      $ret = $self->run(
          [
              @REQ, "-new", ( defined $1 ? ( $1, ) : () ),
              "-keyout", $NEWKEY, "-out", $NEWREQ, $$extra{req}->@*
          ]
      );
  
      say "Request is in $NEWREQ, private key is in $NEWKEY" if $ret == 0;
  }
  
  method newca {
  
      # create the directory hierarchy
      my @dirs = (
          "$CATOP",     "$CATOP/certs",
          "$CATOP/crl", "$CATOP/newcerts",
          "$CATOP/private"
      );
  
      if (
          my $fileexists =
          first { -f $_ } map { "$CATOP/$_" } qw(index.txt serial)
        )
      {
          err "'$fileexists' exists.\nRemove old sub-tree to proceed.", $?;
      }
  
      foreach my $d (@dirs) {
          -d $d
            ? warn "Directory $d exists"
            : mkdir $d
            or err "Can't make directory at $d:\n> mkdir exited with $? - $!", $?;
      }
  
      $self->touch("$CATOP/index.txt");
  
      open my $OUT, '>', "$CATOP/crlnumber";
      say $OUT "01";
      close $OUT;
  
      # ask user for existing CA certificate
      say "CA certificate filename (or enter to create)";
  
      my $FILE;
  
      $FILE = "" unless defined( $FILE = <STDIN> );
      $FILE =~ s{\R$}{};
  
      if ( $FILE ne "" ) {
          $self->copy_pemfile( "$CATOP/$FILE", "$CATOP/private/$CAKEY",
              "PRIVATE" );
          $self->copy_pemfile( "$CATOP/$FILE", "$CATOP/$CACERT", "CERTIFICATE" );
      }
      else {
          say "Making CA certificate...";
  
          my $ret = $self->run(
              [
                  @REQ,                    qw(-new -keyout),
                  "$CATOP/private/$CAKEY", "-out",
                  "$CATOP/$CAREQ",         $$extra{req}->@*
              ]
          );
  
          warn $@ if $? != 0;
  
          $ret = $self->run(
              [
                  @CA,                 qw(-create_serial -out),
                  "$CATOP/$CACERT",    @CADAYS,
                  qw(-batch -keyfile), "$CATOP/private/$CAKEY",
                  "-selfsign",         @EXTENSIONS,
                  "-infiles",          "$CATOP/$CAREQ",
                  $$extra{ca}->@*
              ]
          );
  
          warn $@                                   if $? != 0;
          say "CA certificate is in $CATOP/$CACERT" if $? == 0;
      }
  }
  
  #elsif ( $WHAT eq '-pkcs12' ) {
  method pkcs12 {
      my $cname = $ARGV[0];
      $cname = "My Certificate" unless defined $cname;
  
      $ret = $self->run(
          [
              @PKCS12,          "-in",
              $NEWCERT,         "-inkey",
              $NEWKEY,          "-certfile",
              "$CATOP/$CACERT", "-out",
              $NEWP12,          qw(-export -name),
              $cname,           $$extra{pkcs12}->@*
          ]
      );
  
      say "PKCS#12 file is in $NEWP12" if $ret == 0;
  }
  
  method xsign {
      $ret = $self->run( [ @CA, @POLICY, "-infiles", $NEWREQ, $$extra{ca}->@* ] );
  }
  
  method sign {
      $ret = $self->run(
          [
              @CA, @POLICY, "-out", $NEWCERT, "-infiles", $NEWREQ,
              $$extra{ca}->@*
          ]
      );
  
      say "Signed certificate is in $NEWCERT" if $ret == 0;
  }
  
  method signCA {
      $ret = $self->run(
          [
              @CA,         @POLICY,    "-out",  $NEWCERT,
              @EXTENSIONS, "-infiles", $NEWREQ, $$extra{ca}->@*
          ]
      );
  
      say "Signed CA certificate is in $NEWCERT" if $ret == 0;
  }
  
  method signcert {
      $ret = $self->run(
          [
              @X509,   qw(-x509toreq -in),
              $NEWREQ, "-signkey",
              $NEWKEY, qw(-out tmp.pem),
              $$extra{x509}->@*
          ]
      );
      $ret = $self->run(
          [
              @CA,                  @POLICY,
              "-out",               $NEWCERT,
              qw(-infiles tmp.pem), $$extra{ca}->@*
          ]
      ) if $ret == 0;
  
      say "Signed certificate is in $NEWCERT" if $ret == 0;
  }
  
  method verify {
      my @files = @ARGV ? @ARGV : ($NEWCERT);
  
      foreach my $file (@files) {
          my $status = $self->run(
              [
                  @VERIFY, "-CAfile", "$CATOP/$CACERT", $file,
                  $$extra{verify}->@*
              ]
          );
          $ret = $status if $status != 0;
      }
  }
  
  method crl {
      $ret =
        $self->run(
          [ @CA, qw(-gencrl -out), "$CATOP/crl/$CACRL", $$extra{ca}->@* ] );
      say "Generated CRL is in $CATOP/crl/$CACRL" if $ret == 0;
  }
  
  method revoke ( $cmake, $crl_reason ) {
      my $cname = $ARGV[0];
  
      if ( !defined $cname ) {
          say "Certificate filename is required; reason optional.";
          exit 1;
      }
  
      my @reason;
      @reason = ( "-crl_reason", $ARGV[1] )
        if defined $ARGV[1] && $self->crl_reason_ok( $ARGV[1] );
  
      $ret = $self->run( [ @CA, "-revoke", $cname, @reason, $$extra{ca}->@* ] );
  }
  
  method unknown_arg {
      warn "Unknown arg \"$what\"\n";
      warn "Use -help for help.\n";
      exit 1;
  }
  
  __END__
  
  =encoding utf-8
  
  =head1 NAME
  
  App::OpenSSL::CA - It's new $module
  
  =head1 SYNOPSIS
  
      use App::OpenSSL::CA;
  
  =head1 DESCRIPTION
  
  App::OpenSSL::CA is ...
  
  =head1 LICENSE
  
  Copyright (C) Ian P Bradley.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 AUTHOR
  
  Ian P Bradley E<lt>ian.bradley@studiocrabapple.comE<gt>
  
  =cut
APP_OPENSSL_CA

$fatpacked{"App/OpenSSL/CA/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_OPENSSL_CA_BASE';
  use Object::Pad ':experimental(:all)';
  
  package App::OpenSSL::CA::Base;
  role App::OpenSSL::CA::Base;
  
  use utf8;
  use v5.40;
  
  use Const::Fast::Exporter;
  use Data::Dumper;
  use Time::HiRes;
  use Time::Piece;
  use Time::Moment;
  use Syntax::Keyword::Dynamically;
  #use Exporter 'import';
  
  use subs qw(dmsg epoch err);
  
  BEGIN {
      require Exporter;
      our @ISA = qw(Exporter);
      our @EXPORT = qw(dmsg epoch err);
  }
  
  const our $DEBUG        => $ENV{DEBUG} // 0;
  const our $S_UNKNOWNERR => 'Unknown fatal error';
  
  eval "use Devel::StackTrace::WithLexicals" if $DEBUG;
  
  field $debug :accessor :param = $DEBUG;
  
  APPLY ($mop) {
      use utf8;
      use v5.40;
  
      use Exporter 'import';
      our @EXPORT = @{__PACKAGE__::EXPORT}
  };
  
  ADJUSTPARAMS($param) {
      use utf8;
      use v5.40;
      our @EXPORT = qw(dmsg epoch err);
  }
  
  sub epoch( $join = '', %opts) {
      join $join, Time::HiRes::gettimeofday;
  }
  
  sub dmsg ( @msgs ) {
      $DEBUG || return '';
  
      my @caller = caller 0;
  
      my $out = "*** " . localtime->datetime . " - DEBUG MESSAGE ***\n\n";
  
      dynamically $Data::Dumper::Pad    = "  ";
      dynamically $Data::Dumper::Indent = 1;
  
      $out .=
          scalar @msgs > 1 ? Dumper(@msgs)
        : ref $msgs[0]     ? Dumper(@msgs)
        :                    eval { my $s = $msgs[0] // 'undef'; "  $s\n" };
  
      $out .= "\n";
  
      $out .=
        $ENV{DEBUG} && $ENV{DEBUG} == 2
        ? join "\n", map { ( my $line = $_ ) =~ s/^\t/  /; "  $line" } split /\R/,
        Devel::StackTrace::WithLexicals->new(
          indent      => 1,
          skip_frames => 1
        )->as_string
        : "at $caller[1]:$caller[2]";
  
      say STDERR "$out\n";
      $out;
  }
  
  sub err : prototype($;$%) (
      $msg = ( $! // $S_UNKNOWNERR ),
      $exit     = ( $? ? $? >> 8 : 255 ), %opts
    )
  {
      dmsg( { exit => $exit, msg => $msg, opts => \%opts } );
  
      my $errstr = $msg isa 'ARRAY' ? join "\n", map {
          my $str = $_ isa 'HASH' ? $$_{msg} : $_;
          $str = $S_UNKNOWNERR if $str =~ /^[0-9]+$/ && $str == 0;
          $str
      } @$msg : $msg;
  
      die "ERROR: $errstr ($exit)";
  }
  
  method help : common ( $error = "", $exit = ($? >> 8 || 0)) {
      my $caller = [ caller 0 ];
  
      warn "$error $$caller[0]:$$caller[1] line " . __LINE__ . "\n\n" if $error;
  
      $class->dmsg( { caller => $caller, ( $error ? ( error => $error ) : () ) } )
        if $DEBUG > 1;
  
      warn <<EOF;
  Usage:
      CA.pl -newcert | -newreq | -newreq-nodes | -xsign | -sign | -signCA | -signcert | -crl | -newca [-extra-cmd parameter]
      CA.pl -pkcs12 [certname]
      CA.pl -verify certfile ...
      CA.pl -revoke certfile [reason]
  EOF
      exit $exit;
  }
  
APP_OPENSSL_CA_BASE

$fatpacked{"App/OpenSSL/CA/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_OPENSSL_CA_UTIL';
  use Object::Pad ':experimental(:all)';
  
  package App::OpenSSL::CA::Util;
  role App::OpenSSL::CA::Util : does(App::OpenSSL::CA::Base);
  
  use utf8;
  use v5.40;
  
  use Syntax::Keyword::Dynamically;
  
  sub rc4 : prototype($$;$) ( $message, $key, $skip = undef ) {
      my @s       = 0 .. 255;
      my @k       = unpack 'C*', $key;
      my @message = unpack 'C*', $message;
  
      #my ( $x, $y );
      $skip = 256 unless ( defined $skip );
  
      my $y = 0;
  
      for my $x ( 0 .. 255 ) {
          @s[ $x, $y ] = @s[ $y, $x ];
      }
  
      my $x = 0;
      $y = 0;
  
      for my $i ( 1 .. $skip ) {
          $x = ( $x + 1 ) % 256;
          $y = ( $y + $s[$x] ) % 256;
          @s[ $x, $y ] = @s[ $y, $x ];
      }
  
      for my $msg (@message) {
          $x = ( $x + 1 ) % 256;
          $y = ( $y + $s[$x] ) % 256;
          @s[ $x, $y ] = @s[ $y, $x ];
          $msg ^= $s[ ( $s[$x] + $s[$y] ) % 256 ];
      }
  
      pack 'C*', @message;
  }
  
  sub hide_data : prototype($$$$;$)
    ( $data, $bytes, $key, $secret, $base64 = undef ) {
      my $crypt =
        rc4( null_string($bytes), make_key( $key, $secret, 32 ) . $data );
  
      return encode_base64( $crypt, "" ) if $base64;
      return $crypt;
  }
  
  method cfg_expand : common : prototype($%) ( $str, %grammar ) {
      my $expanded = $str =~ s/%(\w+)%/
  		  my @expansions=@{$grammar{$1}};
  		  $class->cfg_expand($expansions[rand @expansions],%grammar);
  	  /rxge;
  
      $expanded;
  }
  
  method make_anonymous : common ( $salt = __PACKAGEs__->epoch ) {
      my $string = `hostname`;
      $string .= ",$salt";
  
      srand unpack "N",
        hide_data( $string, 3, "silly",
          Net::SSLeay::SHA512( Net::SSLeay::gen_random(32) ) );
  
      $class->cfg_expand(
          "%G% %W%",
          W => [
              "%B%%V%%M%%I%%V%%F%", "%B%%V%%M%%E%",
              "%O%%E%",             "%B%%V%%M%%I%%V%%F%",
              "%B%%V%%M%%E%",       "%O%%E%",
              "%B%%V%%M%%I%%V%%F%", "%B%%V%%M%%E%"
          ],
          B => [
              "B",  "B",  "C",  "D",  "D", "F", "F", "G", "G",  "H",
              "H",  "M",  "N",  "P",  "P", "S", "S", "W", "Ch", "Br",
              "Cr", "Dr", "Bl", "Cl", "S"
          ],
          I => [
              "b", "d", "f", "h", "k",  "l", "m", "n",
              "p", "s", "t", "w", "ch", "st"
          ],
          V => [ "a", "e", "i", "o", "u" ],
          M => [
              "ving",  "zzle",  "ndle",  "ddle",  "ller", "rring",
              "tting", "nning", "ssle",  "mmer",  "bber", "bble",
              "nger",  "nner",  "sh",    "ffing", "nder", "pper",
              "mmle",  "lly",   "bling", "nkin",  "dge",  "ckle",
              "ggle",  "mble",  "ckle",  "rry"
          ],
          F => [
              "t",  "ck",  "tch", "d",   "g",   "n",
              "t",  "t",   "ck",  "tch", "dge", "re",
              "rk", "dge", "re",  "ne",  "dging"
          ],
          O => [
              "Small",    "Snod",   "Bard",    "Billing",
              "Black",    "Shake",  "Tilling", "Good",
              "Worthing", "Blythe", "Green",   "Duck",
              "Pitt",     "Grand",  "Brook",   "Blather",
              "Bun",      "Buzz",   "Clay",    "Fan",
              "Dart",     "Grim",   "Honey",   "Light",
              "Murd",     "Nickle", "Pick",    "Pock",
              "Trot",     "Toot",   "Turvey"
          ],
          E => [
              "shaw",  "man",   "stone", "son",   "ham",   "gold",
              "banks", "foot",  "worth", "way",   "hall",  "dock",
              "ford",  "well",  "bury",  "stock", "field", "lock",
              "dale",  "water", "hood",  "ridge", "ville", "spear",
              "forth", "will"
          ],
          G => [
              "Albert",    "Alice",     "Angus",     "Archie",
              "Augustus",  "Barnaby",   "Basil",     "Beatrice",
              "Betsy",     "Caroline",  "Cedric",    "Charles",
              "Charlotte", "Clara",     "Cornelius", "Cyril",
              "David",     "Doris",     "Ebenezer",  "Edward",
              "Edwin",     "Eliza",     "Emma",      "Ernest",
              "Esther",    "Eugene",    "Fanny",     "Frederick",
              "George",    "Graham",    "Hamilton",  "Hannah",
              "Hedda",     "Henry",     "Hugh",      "Ian",
              "Isabella",  "Jack",      "James",     "Jarvis",
              "Jenny",     "John",      "Lillian",   "Lydia",
              "Martha",    "Martin",    "Matilda",   "Molly",
              "Nathaniel", "Nell",      "Nicholas",  "Nigel",
              "Oliver",    "Phineas",   "Phoebe",    "Phyllis",
              "Polly",     "Priscilla", "Rebecca",   "Reuben",
              "Samuel",    "Sidney",    "Simon",     "Sophie",
              "Thomas",    "Walter",    "Wesley",    "William"
          ],
      );
  }
  
  method __pkgfn__ : common ($pkgname = undef) {
      $pkgname //= $class;
      "$pkgname.pm" =~ s/::/\//rg;
  }
APP_OPENSSL_CA_UTIL

$fatpacked{"App/OpenSSL/SAN.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_OPENSSL_SAN';
  use Object::Pad ':experimental(:all)';
  
  package App::OpenSSL::SAN;
  
  class App::OpenSSL::SAN;
  
  use utf8;
  use v5.40;
  
  use Object::Pad ':experimental(:all)';
  
  method $SAN_tostr : common ($SAN, %opts) {
      my $SAN_str = "subjectAltName=";
  
      foreach my $key ( keys %$SAN ) {
          my $i = 0;
          foreach my $entry ( $SAN->$key->@* ) {
              $SAN_str .= uc($key) . ".0:$entry";
              $i++;
          }
      }
  }
  
  use overload "" => $SAN_tostr;
  
  field $ip    : param = [q'127.0.0.1 ::1'];
  field $dns   : param = [qw(localhost)];
  field $email : param = undef;
  
  ADJUSTPARAMS($params) {
      $self->doctor_SAN(%$params)
  };
  
  method add_ip ($ip) {
      $self->add_to_san( ip => $ip );
  }
  
  method doctor_SAN { $self->append_to_SAN(@_) }
  
  method add_to_san (%fields) {
      foreach my ( $field, $val ) (%fields) {
          $self->$field isa 'ARRAY'
            ? push $self->$field->@*, $val
            : $self->add_to_san( $field => $val );
      }
  }
  
  method SAN : common (%fields) {
      SAN->new( %fields{q'ip dns email'} );
  }
  
  method as_ASN1(%opts) {
  }
  
  method tostr ( $SAN, %opts ) {
  
  }
  
APP_OPENSSL_SAN

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


use utf8;
use v5.40;

use lib 'lib';

use App::OpenSSL::CA;

our $RET = 0;
$RET = App::OpenSSL::CA->do( \@ARGV );

exit $RET

